using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;
using System.Threading;
using System.Security.Cryptography;


namespace EmbedMalware
{
    public partial class Form1 : Form
    {
        private readonly double _threshold = 8.0;
        private readonly double _divideoperator = 2.0; String _statusOfThatWindow = "Normal";
        private int _startEmbedDetected; int _stopEmbedDetected;
        private bool _confirmEmbeddedIsThere;

        private bool _firstSensor;
        private bool _secondSensor;
        private bool _bindingFirstAndSecondSensortoIndicateStartAndStopEmbeddedRegion1;
        private bool _bindingFirstAndSecondSensortoIndicateStartAndStopEmbeddedRegion2;
        private double _pertubationValue;
        private int _lastVer2;
        private int _fileCounter;
        private int _exeSize;
        private int _jpegSize;
        private int _start; // count the start location of EXE insertion in JPEG binary
        private readonly List<int> _estart = new List<int>();
        private readonly List<int> _estop = new List<int>();
        private int _last;// count the last location of EXE insertion in JPEG binary
        private string _embedExe;
        private string _embedJpeg;
        //string NewEmbedJPEG;
        private string _embedAllJpeg;

        //-------------ok------------
        //path for all dirs
        private const string STR_PATH_JPG = @"C:\project\JPEG1";
        private const string STR_PATH_EXE = @"C:\project\EXE";
        private const string STR_PATH_EMBED = @"C:\project\Embedded";
        private const string STR_PATH_RESTORED_JPG = @"C:\project\Restored~JPEG";
        private const string STR_PATH_RESTORED_EXE = @"C:\project\Restored~EXE";

        //// all variables related to checkHash()
        // check hash values
        private readonly string _strOriExe = "";
        private readonly string _strOriJpg = "";
        private readonly string _strEmbedFile = "";
        private readonly string _strRestoredFile = "";
        private readonly string _strRestoredExe = "";
        //------------------------------
        private static readonly Random _rdm = new Random();

        //generate form each time executed

        public Form1()
        {
            InitializeComponent();
        }

        //button when click will reset the text area
        private void clear_Click(object sender, EventArgs e)
        {
            this.Text = "";
            rtbOut1.Clear();
        }

        //this method will embed the JPEG file with exe file


        //used by checkHash function
        static string ByteArrayToString(byte[] arrInput)
        {
            int i = 0;
            StringBuilder sOutput = new StringBuilder(arrInput.Length);
            for (i = 0; i < arrInput.Length - 1; i++)
            {
                sOutput.Append(arrInput[i].ToString("X2"));
            }
            return sOutput.ToString();
        }

        private void CheckHash()
        {
            byte[] restoredExe = File.ReadAllBytes(STR_PATH_RESTORED_EXE + _strRestoredExe);
            rtbOut1.AppendText("EXE's restored Length " + restoredExe.Length + "\n"); ;
            byte[] restoredJpg = File.ReadAllBytes(STR_PATH_RESTORED_JPG + _strRestoredFile);
            rtbOut1.AppendText("JPEG's restored Length " + restoredJpg.Length + "\n"); ;
            this.Text = "Done"; rtbOut1.AppendText("\n\n\n");

            //compute HASH value

            byte[] tmpSource;
            byte[] tmpSource2;
            byte[] tmpSourceExe;
            byte[] tmpHash;
            byte[] tmpHashExe;

            // SourceData
            tmpSource = File.ReadAllBytes(STR_PATH_JPG + _strOriJpg);
            //Create a byte array from source data

            //Compute hash based on source data
            tmpHash = new MD5CryptoServiceProvider().ComputeHash(tmpSource);
            rtbOut1.AppendText("JPEG's Integrity Verification" + "\n\n\n" + " Original JPEG Hash Value: " + ByteArrayToString(tmpHash) + "\n");

            //read all byte in strPathEmbed
            tmpSource2 = File.ReadAllBytes(STR_PATH_EMBED + _strEmbedFile);

            byte[] tmpNewHash;

            tmpNewHash = new MD5CryptoServiceProvider().ComputeHash(tmpSource2);
            rtbOut1.AppendText(" Embedded JPEG Hash Value: " + ByteArrayToString(tmpNewHash) + "\n");



            //Source EXE
            tmpSourceExe = File.ReadAllBytes(STR_PATH_EXE + _strOriExe);
            //Create a byte array from source data

            //////Compute hash based on source data
            tmpHashExe = new MD5CryptoServiceProvider().ComputeHash(tmpSourceExe);
            rtbOut1.AppendText("EXE's Integrity Verification" + "\n\n\n" + " Original EXE Hash Value: " + ByteArrayToString(tmpHashExe) + "\n");


            //write the data in log file
            StreamWriter swl = File.AppendText(@"C:\project\Embedded Data\LogFile.txt");
            swl.WriteLine("Total EXE:" + ExeTotal);
            swl.WriteLine("Total JPEG:" + SizeJpeg);

            swl.WriteLine("Stop inserting EXE binary at :" + _last);
            swl.WriteLine("EXE's restored Length " + restoredExe.Length);
            swl.WriteLine("JPEG's restored Length " + restoredJpg.Length);
            swl.WriteLine(" Original JPEG Hash Value: " + ByteArrayToString(tmpHash));
            swl.WriteLine(" Embedded JPEG Hash Value: " + ByteArrayToString(tmpNewHash));
            //       SWL.WriteLine("Restored JPEG Hash Value:" + ByteArrayToString(tmpNewHash1));
            swl.Close();
            rtbOut1.AppendText("\n Compare the " + STR_PATH_JPG + _strOriJpg + " with " + STR_PATH_EMBED + _strEmbedFile + "\n");
            CompareHash(tmpHash, tmpNewHash);

            //------------source3
            tmpSource2 = File.ReadAllBytes(STR_PATH_RESTORED_JPG + _strRestoredFile);

            tmpNewHash = null; ;

            tmpNewHash = new MD5CryptoServiceProvider().ComputeHash(tmpSource2);
            rtbOut1.AppendText(" Embedded JPEG Hash Value: " + ByteArrayToString(tmpNewHash) + "\n");


            rtbOut1.AppendText("\n Compare the " + STR_PATH_JPG + _strOriJpg + " with " + STR_PATH_RESTORED_JPG + _strRestoredFile + "\n");

            CompareHash(tmpHash, tmpNewHash);

        }

        //used in check hash method
        void CompareHash(byte[] tmpHash, byte[] tmpNewHash)
        {

            bool bEqual = false;
            if (tmpNewHash.Length == tmpHash.Length)
            {
                int i = 0;
                while ((i < tmpNewHash.Length) && (tmpNewHash[i] == tmpHash[i]))
                {
                    i += 1;
                }
                if (i == tmpNewHash.Length)
                {
                    bEqual = true;
                }
            }

            if (bEqual)
                rtbOut1.AppendText("The two hash values are the same\n\n");

            else
                rtbOut1.AppendText("The two hash values are not the same\n\n");
            // Console.ReadLine();
        }


        //button extract that will trigger extract funtion
        private void btnExtract_Click(object sender, EventArgs e)
        {
            Extract();
        }

        //this method perform extract method
        private void Extract()
        {
            String[] arrExe = Directory.GetFiles(STR_PATH_EXE);
            String[] arrNewJpeg = Directory.GetFiles(@"C:\project\Embed All");

            for (int c = 0; c < arrExe.Length; c++)
            {
                string actualExe = arrExe[c];
                string embedJpeg = arrNewJpeg[c];
            }

            byte[] exe = File.ReadAllBytes(STR_PATH_EXE);
            byte[] newJpeg = File.ReadAllBytes(txtNewJPEG.Text);

            int exeSize = exe.Length;
            int jpegSize = newJpeg.Length;

            FileStream fsRestoredNewJpeg = File.Create(@"C:\project\log1.txt");
            BinaryWriter sww2 = new BinaryWriter(fsRestoredNewJpeg);
            FileStream fsRestoredJpeg = File.Create(@"C:\project\Extracted File JPEG\ExtractedJPEG.jpg");
            BinaryWriter swRestoreJpeg = new BinaryWriter(fsRestoredJpeg);

            // implant exe at random location number
            int at = newJpeg.Length;
            int cnt = 0;


            foreach (byte x in newJpeg)
            {
                //extract EXE from JPEG

                if ((cnt >= newJpeg.Length - exeSize))
                {
                    sww2.Write((byte)(x + 1));
                    //d++;
                }
                else
                {
                    swRestoreJpeg.Write(x);

                } cnt++;
                // return;
            }

            sww2.Close();
            swRestoreJpeg.Close();

            byte[] restoredNewJpeg = File.ReadAllBytes(@"C:\project\Extracted File JPEG\ExtractedJPEG.jpg");
            rtbOut1.AppendText("Size of Embedded JPEG is: " + newJpeg.Length + "\n" + "Size of Original JPEG is: " + restoredNewJpeg.Length + "\n"); ;
            StreamWriter ext = File.AppendText(@"C:\project\Extracted File JPEG\ExtractedJPEG.txt");

            foreach (byte x in restoredNewJpeg)
            {
                ext.WriteLine("Size of Embedded JPEG is: " + newJpeg.Length + "\n" + "Size of Original JPEG is: " + restoredNewJpeg.Length + "\n");
            }
            ext.Close();
        }


        private void btnEA_Click(object sender, EventArgs e)
        {


            //getfiile from directory
            List<string> files = new List<string>();
            if (!Directory.Exists(STR_PATH_EXE))
                Directory.CreateDirectory(STR_PATH_EXE);
            string[] arr = Directory.GetFiles(STR_PATH_EXE);

            if (!Directory.Exists(STR_PATH_JPG))
                Directory.CreateDirectory(STR_PATH_JPG);
            string[] arr1 = Directory.GetFiles(STR_PATH_JPG);
            int totalFileExe = arr.Length;
            int totalFileJpeg = arr1.Length;

            rtbOut1.AppendText("Total EXE Files:" + totalFileExe + "\n" + "Total JPEG Files:" + totalFileJpeg + "\n\n");

            if (!Directory.Exists(@"C:\project\Embed All 1\Restored JPEG"))
                Directory.CreateDirectory(@"C:\project\Embed All 1\Restored JPEG");
            String[] filesW = Directory.GetFiles(@"C:\project\Embed All 1\Restored JPEG");

            if (!Directory.Exists(@"C:\project\Embed All 1\Restored EXE"))
                Directory.CreateDirectory(@"C:\project\Embed All 1\Restored EXE");
            String[] filesX = Directory.GetFiles(@"C:\project\Embed All 1\Restored EXE");

            if (!Directory.Exists(@"C:\project\Embed All\"))
                Directory.CreateDirectory(@"C:\project\Embed All\");
            String[] filesEmbedAll = Directory.GetFiles(@"C:\project\Embed All\");

            //This loop will delete files in C:\project\Embed All 1\Restored JPEG
            foreach (String fW in filesW)
            {
                File.Delete(fW);
            }
            //This loop will delete files in C:\project\Embed All 1\Restored EXE
            foreach (String fX in filesX)
            {
                File.Delete(fX);
            }
            //This loopp will delete files in C:\project\Embed All\
            foreach (String fEa in filesEmbedAll)
            {
                File.Delete(fEa);
            }
            if (File.Exists(@"C:\project\summary\" + "SummaryResult.txt"))
                File.Delete(@"C:\project\summary\" + "SummaryResult.txt");
            //--------write Summary------------------
            if (!Directory.Exists(@"C:\project\summary"))
                Directory.CreateDirectory(@"C:\project\summary");

            StreamWriter summary1 = File.AppendText(@"C:\project\summary\" + "SummaryResult.txt");
            summary1.WriteLine("shortFileNames" + "," + "THRESHOLD" + "," + "DIVIDEOPERATOR" + "," + "AllEmbed.Length" + "," + "Counter" + "," + "Estart[fileCounter - 1]" + "," + "Estop[fileCounter - 1]" + "," + "std" + "," + "StartEmbedDetected" + "," + "StopEmbedDetected" + "," + "(Estart[fileCounter - 1] - StartEmbedDetected)" + "," + "(Estop[fileCounter - 1] - StopEmbedDetected)");
            summary1.Close();//--------------------------


            string[] embeddedJpeg;
            // take each files from the EXE dir. and JPEG dir. to combine the binary
            for (int c = 0; c < arr.Length; c++)
            {
                _fileCounter++;
                //       if (c == 1) break; //single embed
                _embedExe = arr[c]; //exe
                _embedJpeg = arr1[c];

                EmbedAll();
                embeddedJpeg = Directory.GetFiles(@"C:\project\Embed All");
                _embedded = embeddedJpeg[c];
                Ngram();
                // break; //only 1 file
            }

        }

        public void EmbedAll()
        {
            int countw = 0;
            byte[] allExe = File.ReadAllBytes(_embedExe);
            byte[] allJpeg = File.ReadAllBytes(_embedJpeg);

            _exeSize = allExe.Length;
            _jpegSize = allJpeg.Length;

            string[] shortNames = _embedJpeg.Split('\\');


            //    double ratio = Convert.ToDouble(EXESize) / JPEGSize;
            //getting the middlepoint value for each jpeg to embed
            //setting the maximum tolerance level to locate the embedded exe
            //at = middlePoint * 2 - 300; <---proven value!!!
            int middlePoint = _jpegSize / 2;
            int toleranceRange = 300;
            int at = _rdm.Next(_jpegSize - toleranceRange, _jpegSize - toleranceRange);// implant exe at certain location
            _start = at;
            _estart.Add(at);
            //middle point just for showing, embed occur at another place for now!            
            //Embed occur at location 300 byte before end!
            rtbOut1.AppendText("Total EXE:" + _exeSize + "\n\n" + "Total JPEG:" + _jpegSize + "," + "middlePoint" + "," + middlePoint + "," + "at" + "," + at + "\n\n");

            List<byte> jpegBinary = new List<byte>(allJpeg);

            byte[] tempJpegBinary = jpegBinary.ToArray();
            string[] shortFileNames = _embedJpeg.Split('\\');


            File.Delete(@"C:\project\Embed All\" + shortFileNames[shortFileNames.Length - 1]);


            FileStream fs = File.Create(@"C:\project\Embed All\" + shortFileNames[shortFileNames.Length - 1]);

            BinaryWriter sww = new BinaryWriter(fs);

            bool t = false;
            List<byte> raw = new List<byte>();
            int count = 0;
            // at = TempJPEGBinary.Length / 2;
            foreach (byte aa in tempJpegBinary)
            {
                count++;

                if (count == at)
                {
                    _last = 0;
                    //insert EXE binary data

                    foreach (byte c in allExe)
                    {
                        _last++;
                        countw++;
                        if (t == false)
                        {
                            t = true;
                            rtbOut1.AppendText("Begin inserting EXE binary at :" + at + "\nfirst byte is :" + c + "\n");
                        }

                        if (_last == allExe.Length)
                        {
                            rtbOut1.AppendText("last s :" + c + "\n");
                            rtbOut1.AppendText("Stop inserting EXE binary at :" + _lastVer2 + "\n");
                            _lastVer2 = _last + count;
                            _estop.Add(_lastVer2);
                        }

                        int hhData = Encode(c, 3);

                        sww.Write((byte)(hhData)); //ceasar key


                    }
                    sww.Write(aa);
                }
                else
                {
                    sww.Write(aa);
                }
                // start++;
            }
            sww.Close();

            /*******************restore exe and jpeg files**********************************/

            byte[] newJpeg = File.ReadAllBytes(@"C:\project\Embed All\" + shortFileNames[shortFileNames.Length - 1]);
            int newJpeGlength = newJpeg.Length;
            FileStream fsRestoredExe = File.Create(@"C:\project\Embed All 1\Restored EXE\" + shortFileNames[shortFileNames.Length - 1] + "Restored EXE.txt");
            BinaryWriter binExe = new BinaryWriter(fsRestoredExe);
            FileStream fsRestoredJpeg = File.Create(@"C:\project\Embed All 1\Restored JPEG\" + shortFileNames[shortFileNames.Length - 1] + "Restored JPEG.jpg");
            BinaryWriter binJpeg = new BinaryWriter(fsRestoredJpeg);
            int cnt = 1;
            int d = 1;
            int aaq = at + _exeSize;

            for (cnt = at - 1; cnt <= aaq; cnt++)  //byte x in NewJPEG) //foreach (byte x in NewJPEG)
            {
                byte x = newJpeg[cnt];
                if ((cnt >= at - 1) && (d <= _exeSize))
                {
                    int yy = Decode(x, 3);
                    binExe.Write((byte)(yy));

                    if ((cnt >= at) && (cnt < at + 3))
                    {
                        byte x1 = newJpeg[cnt - 1];
                        rtbOut1.AppendText("Begin Restoring EXE binary at :" + cnt + "\nfirst byte is :" + x1 + "\n");
                    }
                    d++;
                }

                if (cnt > (aaq))
                    break;
            }

            binExe.Close();
            binJpeg.Close();
            //End restore
            byte[] restoredExe = File.ReadAllBytes(@"C:\project\Embed All 1\Restored EXE\" + shortFileNames[shortFileNames.Length - 1] + "Restored EXE.txt");
            rtbOut1.AppendText("EXE's restored Length " + restoredExe.Length + "\n"); ;
            byte[] restoredJpg = File.ReadAllBytes(@"C:\project\Embed All 1\Restored JPEG\" + shortFileNames[shortFileNames.Length - 1] + "Restored JPEG.jpg");
            rtbOut1.AppendText("JPEG's restored Length " + restoredJpg.Length + "\n"); ;
            this.Text = "Done"; rtbOut1.AppendText("\n");

            /********************************************************/
            //compute HASH value
            byte[] tmpSource2;
            byte[] tmpSource3;

            tmpSource2 = File.ReadAllBytes(@"C:\project\Embed All\" + shortFileNames[shortFileNames.Length - 1]);

            byte[] tmpNewHash;

            tmpNewHash = new MD5CryptoServiceProvider().ComputeHash(tmpSource2);
            rtbOut1.AppendText(" Embedded JPEG Hash Value: " + ByteArrayToString2(tmpNewHash) + "\n\n");

            tmpSource3 = File.ReadAllBytes(_embedJpeg);

            byte[] tmpNewHash1;

            tmpNewHash1 = new MD5CryptoServiceProvider().ComputeHash(tmpSource3);
            rtbOut1.AppendText(" Original JPEG Hash Value: " + ByteArrayToString2(tmpNewHash1) + "\n");

            //write the data in log file
            StreamWriter swl = File.AppendText(@"C:\project\LogDataEmbedAll.txt");
            swl.WriteLine("Total EXE:" + _exeSize + "," + "\r\n" + "Total JPEG:" + _jpegSize + "," + "\r\n" + "Begin inserting EXE binary at :" + at + "," + "\r\n" + "Stop inserting EXE binary at :" + _lastVer2 + "," + "\r\n" + "Original JPEG's Hash Value: " + ByteArrayToString2(tmpNewHash1) + "," + "\r\n" + "Embedded JPEG's Hash Value:" + ByteArrayToString2(tmpNewHash));
            swl.WriteLine("=================================================");
            swl.Close();

            string delimiter = ",";
            StreamWriter swl2 = File.AppendText(@"C:\project\embedData.csv");
            //Total EXE, Total JPEG, Start Embed at, Stop Embed at, Original Hash, Embedded Hash
            swl2.WriteLine(_exeSize + delimiter + _jpegSize + delimiter + at + delimiter + _lastVer2 + delimiter + ByteArrayToString2(tmpNewHash1) + delimiter + ByteArrayToString2(tmpNewHash));
            swl2.Close();
            //Console.Write("end.....");
        }
        /********************************************************/
        int Encode(int bytX, int stpY)
        {
            bytX = bytX + stpY;
            if (bytX == 256)
            { bytX = 0; }
            if (bytX > 256)
            { bytX = bytX - 256; }
            return bytX;
        }

        /********************************************************/
        int Decode(int bytX, int stpY)
        {
            if (bytX == stpY)
            {
                // return  bytX = 255;
            }
            int u = bytX - stpY;
            // if (bytX==0)
            //  { return bytX - stpY; }
            if (u <= 0)
            {
                bytX = bytX + 256 - stpY;
            }
            else
            {
                bytX = bytX - stpY;
            }
            if (bytX == 256) return 0;
            return bytX;
        }
        /********************************************************/
        //used by hash function in embedAll method
        static string ByteArrayToString2(byte[] arrInput1)
        {
            int i = 0;
            StringBuilder sOutput = new StringBuilder(arrInput1.Length);
            for (i = 0; i < arrInput1.Length - 1; i++)
            {
                sOutput.Append(arrInput1[i].ToString("X2"));
            }
            return sOutput.ToString();
        }

        /**********************************No use for now (4 Dec 2013)***************************************************************/
        private void btnExtractAll_Click(object sender, EventArgs e)
        {
            List<string> files = new List<string>();
            //string[] shortFileNamesAll = EmbedAllJPEG.Split('\\'); 
            string[] arr2 = Directory.GetFiles(@"C:\project\Embed All");

            //int TotalFileJPEG = arr2.Length;

            for (int c = 0; c < arr2.Length; c++)
            {
                _embedAllJpeg = arr2[c];
                ExtractAll();
                // break;
            }
        }
        public void ExtractAll()
        {
            String[] filesJpg = Directory.GetFiles(@"C:\project\Extracted File JPEG\");

            foreach (String fj in filesJpg)
            {
                File.Delete(fj);
            }

            string[] arr1 = Directory.GetFiles(STR_PATH_EXE);
            string[] shortFileNamesExe = _embedExe.Split('\\');
            string[] shortFileNamesAll = _embedAllJpeg.Split('\\');

            //read byte of infected JPEG
            byte[] allEmbedJpeg = File.ReadAllBytes(_embedAllJpeg);
            //read byte of malware
            byte[] exe = File.ReadAllBytes(STR_PATH_EXE + shortFileNamesExe[shortFileNamesExe.Length - 1]);

            int exeTotal = exe.Length;
            int sizeJpeg = allEmbedJpeg.Length;

            // StreamWriter EAJ = File.AppendText(@"C:\project\Extracted File JPEG\Log4.txt");

            //foreach (byte h in EXE)
            {
                //    EAJ.WriteLine(h);
            }
            // EAJ.Close();

            List<byte> exeBinary = new List<byte>(exe);
            //StreamReader ReadTemp2 = new StreamReader(@"C:\project\Extracted File JPEG\Log4.txt");

            for (int count = 0; count < sizeJpeg; count++)
            {
                exeBinary.Add(Convert.ToByte(count));
            }
            //ReadTemp2.Close();

            //convert expression to array variable
            byte[] tempExeBinary = exeBinary.ToArray();

            FileStream fsRestoredNewJpeg = File.Create(@"C:\project\Extracted File JPEG\Log1.txt");
            BinaryWriter sww2 = new BinaryWriter(fsRestoredNewJpeg);
            FileStream fsRestoredJpeg = File.Create(@"C:\project\Extracted File JPEG\" + shortFileNamesAll[shortFileNamesAll.Length - 1]);
            BinaryWriter swRestoreJpeg = new BinaryWriter(fsRestoredJpeg);

            int at = exe.Length;
            int cnt = 0;
            bool f = true;
            List<byte> raw1 = new List<byte>();

            foreach (byte x in _embedAllJpeg)
            {
                //extract EXE from JPEG
                if (at == sizeJpeg)
                {
                    swRestoreJpeg.Write(x);
                }
                else
                {
                    _last = 1;
                    foreach (byte w in _embedAllJpeg)
                    {
                        if (f == true)
                        {
                            f = false;
                            rtbOut1.AppendText("First byte of exe is: " + w);
                        }
                    }
                    sww2.Write((byte)(x + 1));
                    _last++;
                    rtbOut1.AppendText("Size of Original JPEG is: " + x + "\n");
                }

                cnt++;
            }

            sww2.Close();
            swRestoreJpeg.Close();

            byte[] restoredNewJpeg = File.ReadAllBytes(@"C:\project\Extracted File JPEG\" + shortFileNamesAll[shortFileNamesAll.Length - 1]);
            rtbOut1.AppendText("Size of Embedded JPEG is: " + _embedAllJpeg.Length + "\n");
            StreamWriter ext = File.AppendText(@"C:\project\Extracted File JPEG\ExtractedJPEG.txt");

            foreach (byte x in restoredNewJpeg)
            {
                ext.WriteLine("Size of Embedded JPEG is: " + _embedAllJpeg.Length + "\n" + "Size of Original JPEG is: " + restoredNewJpeg.Length + "\n");
            }
            ext.Close();

        }
        /**************************Setter and Getter method***************************************************/

        public string ExeTotal { get; set; }

        public string SizeJpeg { get; set; }
        /****************************************************Find n-gram for original JPEG*************************************************************/
        string _ori;
        string _embed;
        private void ngramJPGOri_Click(object sender, EventArgs e)
        {
            string[] oriJpeg = Directory.GetFiles(STR_PATH_JPG);
            string[] oriExe = Directory.GetFiles(STR_PATH_EXE);
            for (int c = 0; c < oriExe.Length; c++)
            {
                //need to find way to write nyte of individual embedded jpeg to individual text file
                //current solution not working, need to do it manually by changing value of c
                _ori = oriJpeg[c];
                _embed = oriExe[c];
                NgramOri();
                NgramEmbed();
            }
            rtbOut1.AppendText("N-gram done!");
        }

        public void NgramOri()
        {

            byte[] allJpeg = File.ReadAllBytes(_ori);

            _jpegSize = allJpeg.Length;

            string[] shortNames = _ori.Split('\\');

            File.Delete(@"C:\project\n-gram\ori\" + shortNames[shortNames.Length - 1] + "Embed.txt");
            List<int> ngram = new List<int>();
            List<int> entropy = new List<int>();

            StreamWriter eAr = File.AppendText(@"C:\project\n-gram\ori\" + shortNames[shortNames.Length - 1] + "Ori.csv");
            int ngramCounter = 0;

            foreach (byte jj in allJpeg)
            {
                ngramCounter++;

                ngram.Add(jj);
                if (ngramCounter == 100)
                {
                    int total = 0;
                    foreach (int ggg in ngram)
                    { total = total + ggg; }

                    eAr.Write(total);
                    eAr.Write(",");

                    ngramCounter = 0;

                    ngram.Clear();
                    entropy.Clear();
                }


            } eAr.Close();

        }

        public void NgramEmbed()
        {

            byte[] allExe = File.ReadAllBytes(_embed);
            _exeSize = allExe.Length;

            string[] fileNames = _embed.Split('\\');

            File.Delete(@"C:\project\n-gram\exe\" + fileNames[fileNames.Length - 1] + "Embed.txt");
            List<int> ngramExe = new List<int>();
            List<int> entropy = new List<int>();

            StreamWriter eAx = File.AppendText(@"C:\project\n-gram\exe\" + fileNames[fileNames.Length - 1] + ".csv");
            int ngramCounter = 0;

            foreach (byte jj in allExe)
            {
                ngramCounter++;

                ngramExe.Add(jj);
                if (ngramCounter == 100)
                {
                    int total = 0;
                    foreach (int ggg in ngramExe)
                    { total = total + ggg; }

                    eAx.Write(total);
                    eAx.Write(",");

                    ngramCounter = 0;

                    ngramExe.Clear();
                    entropy.Clear();
                }


            } eAx.Close();
        }

        /****************************************************Find n-gram for embedded JPEG*************************************************************/
        string _embedded;
        private void PatternJPEG_Click(object sender, EventArgs e)
        {
            string[] embeddedJpeg = Directory.GetFiles(@"C:\project\Embed All");
            String[] logEmbed = Directory.GetFiles(STR_PATH_EMBED);
            foreach (String fEa in logEmbed)
            {
                File.Delete(fEa);
            }

            for (int c = 0; c < embeddedJpeg.Length; c++)
            {
                //need to find way to write nyte of individual embedded jpeg to individual text file
                //current solution not working, need to do it manually by changing value of c
                _embedded = embeddedJpeg[c];
                Ngram();
            }
            rtbOut1.AppendText("N-gram done!");
        }
        public void Ngram()
        {
            byte[] allEmbed = File.ReadAllBytes(_embedded);
            if (!Directory.Exists(STR_PATH_EMBED))
                Directory.CreateDirectory(STR_PATH_EMBED);
            String[] logEmbed = Directory.GetFiles(STR_PATH_EMBED);
            /*  foreach (String fEA in logEmbed)
              {
                  File.Delete(fEA);
              }
              */
            List<byte> jpgNgram = new List<byte>(allEmbed);
            byte[] tempJpgBin = jpgNgram.ToArray();

            string[] shortFileNames = _embedded.Split('\\');
            File.Delete(@"C:\project\n-gram\embed\" + shortFileNames[shortFileNames.Length - 1] + "Embed.txt");

            List<int> ngram = new List<int>();
            List<int> kj = new List<int>();


            StreamWriter ea = File.AppendText(@"C:\project\n-gram\embed\" + shortFileNames[shortFileNames.Length - 1] + ".csv");
            int ngramCounter = 0;
            int counter = -1;
            StreamWriter eaEmbed = File.AppendText(@"C:\project\Embedded\" + shortFileNames[shortFileNames.Length - 1] + "embed.txt");
            //###################################################
            //###################################################
            double previousStdValue = 0; //trace previous val
            bool once = false;
            bool firstRound = true;
            //###################################################
            //###################################################
            double std1 = 0.0;

            foreach (byte j in allEmbed)
            {
                counter++;
                int sss = 0;
                if (counter == 1585999)
                    sss = 9;
                if (counter == 0)
                    eaEmbed.Write("shortFileNames" + "," + "Length" + "," + "Counter" + "," + "Estart" + "," + "Estop" + "," + "min" + "," + " max" + "," + "mean" + "," + "median" + "," + "variance" + "," + "std" + "," + "status" + "," + "pertubationValue" + "," + "StatusOfThatWindow" + "," + "confirmEmbeddedIsThere" + "," + "StartEmbedDetected" + "," + "StopEmbedDetected" + "\n");

                ngramCounter++;

                ngram.Add(j);
                if (ngramCounter == 100)
                {
                    double total = 0;
                    int kk = 0;
                    foreach (int gg in ngram)
                    {
                        kj.Add(gg);
                        kk = gg;
                        total = total + gg;
                    }

                    ea.Write(total);
                    ea.Write(",");

                    int min = ngram.Min();
                    int max = ngram.Max();

                    double median = 0.0;
                    int[] temp = ngram.ToArray();
                    Array.Sort(temp);
                    int alength = temp.Length;
                    median = temp[alength / 2];

                    double mean = ngram.Average();
                    double variance = 0.0;
                    variance = Math.Pow((kj[0] - mean), 2) / (ngramCounter);
                    double std = StandardDeviation(ngram.Select(x => (double)x).ToArray());
                    std1 = std;

                    bool status = false;
                    if (counter >= _estart[_fileCounter - 1] && counter <= _estop[_fileCounter - 1])
                    {
                        status = true;
                    }
                    else
                    {
                        status = false;
                    }
                    //####################
                    if (firstRound == true)
                    {
                        firstRound = false;
                        _pertubationValue = 0;
                        _statusOfThatWindow = "Normal";
                        previousStdValue = std;
                    }
                    else
                    {
                        _pertubationValue = (previousStdValue + _threshold) / _divideoperator;
                        if (std >= _pertubationValue)
                        {
                            _statusOfThatWindow = "Normal";
                            _firstSensor = false;
                            _secondSensor = false; _confirmEmbeddedIsThere = false;
                        }
                        else
                        {
                            _statusOfThatWindow = "EmbeddedData";

                            if (_firstSensor == true)
                            {
                                _secondSensor = true;
                                _confirmEmbeddedIsThere = true;
                                if (once == false)
                                {
                                    once = true;
                                    _startEmbedDetected = counter;
                                }
                                if (_bindingFirstAndSecondSensortoIndicateStartAndStopEmbeddedRegion1 == true)
                                {
                                    _bindingFirstAndSecondSensortoIndicateStartAndStopEmbeddedRegion2 = true;
                                    _stopEmbedDetected = counter;
                                }
                                if (_bindingFirstAndSecondSensortoIndicateStartAndStopEmbeddedRegion1 == false)
                                {
                                    _bindingFirstAndSecondSensortoIndicateStartAndStopEmbeddedRegion1 = true;

                                }

                            }
                            if (_firstSensor == false)
                            { _firstSensor = true; _confirmEmbeddedIsThere = false; }
                        }
                    }
                    //######################

                    eaEmbed.Write(shortFileNames[shortFileNames.Length - 1] + "," + allEmbed.Length + "," + counter + "," + _estart[_fileCounter - 1] + "," + _estop[_fileCounter - 1] + "," + +min + "," + max + "," + mean + "," + median + "," + variance + "," + std + "," + status + "," + _pertubationValue + "," + _statusOfThatWindow + "," + _confirmEmbeddedIsThere + "," + _startEmbedDetected + "," + _stopEmbedDetected + "\n");
                    previousStdValue = std;
                    ngramCounter = 0;

                    kj.Clear();
                    ngram.Clear();

                }
            }
            //--------write Summary------------------
            StreamWriter summary = File.AppendText(@"C:\project\summary\" + "SummaryResult.txt");
            summary.WriteLine(shortFileNames[shortFileNames.Length - 1] + "," + _threshold + "," + _divideoperator + "," + allEmbed.Length + "," + counter + "," + _estart[_fileCounter - 1] + "," + _estop[_fileCounter - 1] + "," + std1 + "," + _startEmbedDetected + "," + _stopEmbedDetected + "," + (_estart[_fileCounter - 1] - _startEmbedDetected) + "," + (_estop[_fileCounter - 1] - _stopEmbedDetected));
            //--------------------------
            summary.Close();
            eaEmbed.Close();
            ea.Close();
            _start = 0;
            _last = 0;

        }



        /*******************************************8*/


        List<double> _dat6 = new List<double>();




        private static double StandardDeviation(double[] data)
        {

            double ret = 0;
            double dataAverage = 0;
            double totalVariance = 0;
            int max = 0;

            try
            {

                max = data.Length;

                if (max == 0) { return ret; }

                //DataAverage = Average(data);

                for (int i = 0; i < max; i++)
                {
                    totalVariance += Math.Pow(data[i] - dataAverage, 2);
                }

                ret = Math.Sqrt(SafeDivide(totalVariance, max));

            }
            catch (Exception) { throw; }
            return ret;
        }

        private static double SafeDivide(double value1, double value2)
        {

            double ret = 0;

            try
            {

                if ((value1 == 0) || (value2 == 0)) { return ret; }

                ret = value1 / value2;

            }
            catch { }
            return ret;
        }









    }
}






